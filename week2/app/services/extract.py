from __future__ import annotations

import os
import re
from typing import List
import json
from typing import Any
from openai import OpenAI
from dotenv import load_dotenv

load_dotenv()

BULLET_PREFIX_PATTERN = re.compile(r"^\s*([-*â€¢]|\d+\.)\s+")
KEYWORD_PREFIXES = (
    "todo:",
    "action:",
    "next:",
)


def _is_action_line(line: str) -> bool:
    stripped = line.strip().lower()
    if not stripped:
        return False
    if BULLET_PREFIX_PATTERN.match(stripped):
        return True
    if any(stripped.startswith(prefix) for prefix in KEYWORD_PREFIXES):
        return True
    if "[ ]" in stripped or "[todo]" in stripped:
        return True
    return False


def extract_action_items(text: str) -> List[str]:
    lines = text.splitlines()
    extracted: List[str] = []
    for raw_line in lines:
        line = raw_line.strip()
        if not line:
            continue
        if _is_action_line(line):
            cleaned = BULLET_PREFIX_PATTERN.sub("", line)
            cleaned = cleaned.strip()
            # Trim common checkbox markers
            cleaned = cleaned.removeprefix("[ ]").strip()
            cleaned = cleaned.removeprefix("[todo]").strip()
            extracted.append(cleaned)
    # Fallback: if nothing matched, heuristically split into sentences and pick imperative-like ones
    if not extracted:
        sentences = re.split(r"(?<=[.!?])\s+", text.strip())
        for sentence in sentences:
            s = sentence.strip()
            if not s:
                continue
            if _looks_imperative(s):
                extracted.append(s)
    # Deduplicate while preserving order
    seen: set[str] = set()
    unique: List[str] = []
    for item in extracted:
        lowered = item.lower()
        if lowered in seen:
            continue
        seen.add(lowered)
        unique.append(item)
    return unique


def _looks_imperative(sentence: str) -> bool:
    words = re.findall(r"[A-Za-z']+", sentence)
    if not words:
        return False
    first = words[0]
    # Crude heuristic: treat these as imperative starters
    imperative_starters = {
        "add",
        "create",
        "implement",
        "fix",
        "update",
        "write",
        "check",
        "verify",
        "refactor",
        "document",
        "design",
        "investigate",
    }
    return first.lower() in imperative_starters


# ASSIGNMENT 1: GENERATED BY AI
def extract_action_items_llm(text: str, model: str = "gpt-4o-mini") -> List[str]:
    client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))
    system_prompt = (
        "You extract action items from arbitrary notes. "
        "Respond strictly as a JSON object with a single key 'items' that maps to an array of strings. "
        "No additional keys or prose."
    )
    user_prompt = (
        "Extract actionable tasks from the following notes and return only a JSON array of strings.\n\n"
        f"NOTES:\n{text}"
    )

    response = client.chat.completions.create(
        model=model,
        messages=[
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": user_prompt},
        ],
        temperature=0,
        response_format={
            "type": "json_schema",
            "json_schema": {
                "name": "action_items",
                "strict": True,
                "schema": {
                    "type": "object",
                    "additionalProperties": False,
                    "properties": {
                        "items": {
                            "type": "array",
                            "items": {"type": "string"},
                            "minItems": 0,
                            "maxItems": 200,
                        }
                    },
                    "required": ["items"],
                },
            },
        },
    )

    try:
        raw = response.choices[0].message.content or "{}"
        data: Any = json.loads(raw)
        if isinstance(data, dict) and isinstance(data.get("items"), list) and all(
            isinstance(x, str) for x in data["items"]
        ):
            return data["items"]
        return []
    except Exception:
        return []

if __name__ == "__main__":
    text = """
    - [ ] Add a new feature to the app
    - [ ] Fix the bug in the app
    - [ ] Update the documentation
    - [ ] Implement the new feature
    - [ ] Refactor the code
    - [ ] Document the code
    - [ ] Design the new feature
    - [ ] Investigate the bug
    """
    print(extract_action_items_llm(text))